---
title: Overview
order: 0
default: true
---

At its core, **Frisbee** is best described as a <CH.InlineCode>bring-your-own-protocol</CH.InlineCode> messaging framework. Our goal was
to make it possible for Developers to define their **own** messaging patterns and protocols, and have the actual
lower-level implementations done for them by the library.

**FRPC** (or **Frisbee RPC**), on the other hand, is an <Tooltip text={"Remote Procedure Call"} content={"RPC"}/> Framework (similar to [GRPC](https://grpc.io) or
[Apache Thrift](https://thrift.apache.org/)) that uses the Frisbee messaging framework as its underlying transport mechanism.

We built <Tooltip text={"Frisbee RPC"} content={"FRPC"}/> because we loved the idea of defining our message types in a standardized
[proto3](https://developers.google.com/protocol-buffers/docs/proto3) format and having the [protobuf](https://github.com/protocolbuffers/protobuf) compiler generate all the necessary
glue code for us, but we didn't like the [overhead](https://github.com/boguslaw-wojcik/encoding-benchmarks) of encoding and decoding
messages in the <Tooltip text={"Data format used to serialize structured data"} content={"protobuf"}/> format, and wanted a wire protocol that was lighter than HTTP/2.

FRPC works by making use of protobuf plugins, and allows developers to use their existing proto3 files to generate a
full RPC Framework that uses Frisbee under the hood. Moreover, Frisbee is a **drop-in replacement for GRPC** thanks to
our generated interfaces matching GRPC's, and in an apples-to-apples comparison,
[Frisbee RPC blows GRPC's performance out of the water]().

In general we expect that most developers will want to start by using FRPC

# Why is Frisbee Necessary?

Messaging frameworks in general have been around for years, and as distributed systems become the norm, it's more and
more important to have efficient, reliable communication protocols.

Well-defined protocols like [NATS](https://nats.io) or [Kafka](https://kafka.apache.org/) are good at what they do,
however they are designed for very specific use cases, are difficult to embed, and in general aren't very flexible.

Systems like [GRPC](https://grpc.io) on the other hand are supposed to provide more flexibility by allowing developers
to specify message types and handlers on the server-side, however the overhead of GRPC and the requirement of Protocol
Buffers adds unnecessary bloat to applications - not to mention that only the Request/Reply pattern is supported.

[Frisbee](https://github.com/loopholelabs/frisbee), on the other hand allows Developers to implement any messaging
pattern they choose - whether that's PUB/SUB, or Request/Reply or something completely custom. Frisbee is also
significantly more flexible than protocols like GRPC or NATS because it was not designed for just a single use-case,
and instead provides building blocks that can be used to build protocols on top of.

As an example, we wanted to create a simple PUB/SUB application using Frisbee that would perform on-par (or better) than
NATS in an apples-to-apples comparison. The resulting [repository](https://github.com/loopholelabs/frisbee-benchmarks/tree/master/nats-benchmark/frisbee)
is only **300 lines of code** and [out-performs NATS in a real-world test by 10%]().