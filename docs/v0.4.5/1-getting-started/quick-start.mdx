---
title: Quick Start
order: 1
---

In this section we'll be going over how you can quickly get started with <Tooltip text={"Frisbee RPC"} content={"FRPC"}/>,
from defining your message types in a <Tooltip text={"Syntax used to describe protocol buffers"} content={"proto3"}/> file, to writing your first server and client.

We'll be building a simple echo service that will echo back the message it receives, and later on we'll also show how
you can use the Frisbee framework itself to build a more complex <Tooltip text={"Publish and Subscribe"} content={"PUB\/SUB"}/> service.

# Installation

To get started with <Tooltip text={"Frisbee RPC"} content={"FRPC"}/>, you'll need to make sure you have <CH.InlineCode>Go</CH.InlineCode>
and the <CH.InlineCode>protoc</CH.InlineCode> compiler installed. Then, you'll need to install
the <CH.InlineCode>protoc-gen-frisbee</CH.InlineCode> <Tooltip text={"Plugins hook into the protoc compiler and allow for custom code generation"} content={"protoc plugin"}/>
which we will use to generate the server and client code.

## Prerequisites

- [Go](https://golang.org/doc/install) - FRPC works with <CH.InlineCode>Go</CH.InlineCode> version 1.17 or later. For installation instructions see [Go's Getting Started Guide](https://golang.org/doc/install).
- [Protocol Buffer Compiler (protoc)](https://developers.google.com/protocol-buffers) - FRPC works with <CH.InlineCode>protoc</CH.InlineCode> version 3. For installation instructions see the [Protoc Getting Started Guide](https://developers.google.com/protoc/docs/getting_started).

If you're using MacOS and have [Brew](https://brew.sh/) installed, you can use <CH.InlineCode>brew install go</CH.InlineCode>
to install Golang, and <CH.InlineCode>brew install protoc</CH.InlineCode> to install the protoc compiler.

## Install the FRPC Plugin

To install the <CH.InlineCode>protoc-gen-frisbee</CH.InlineCode> plugin, you'll first need to make sure that your

<CH.InlineCode>$GOBIN</CH.InlineCode> environment variable is set and available in
your system path. See the [Go Environment Variables](https://golang.org/doc/code.html#GOPATH)
for more information, but in general, you can do this by adding the following to
your <CH.InlineCode>~/.bashrc</CH.InlineCode> file:

```nix ~/.bashrc
export GOBIN=$GOPATH/bin
export PATH=$PATH:$GOBIN
```

To install the <CH.InlineCode>protoc-gen-frisbee</CH.InlineCode> plugin itself, you'll need to run the following command:

```nix
$ go install github.com/loopholelabs/frisbee/protoc-gen-frisbee@latest
```

This will install the <CH.InlineCode>protoc-gen-frisbee</CH.InlineCode> plugin into your <CH.InlineCode>$GOBIN</CH.InlineCode> directory
where it will be available for use by the <CH.InlineCode>protoc</CH.InlineCode> compiler.

You can check that the plugin is installed and available by running the following command:

```nix
$ which protoc-gen-frisbee

/Users/<username>/go/bin/protoc-gen-frisbee # or $GOPATH/bin/protoc-gen-frisbee
```

# Create a Proto3 File

Now that we have the prerequisites and the <CH.InlineCode>protoc-gen-frisbee</CH.InlineCode> plugin installed,
we can start writing our echo service. Let's start by creating a directory to house our project:

```nix
$ mkdir -p ~/frpc/echo
$ cd ~/frpc/echo
```

Now we'll create an <CH.InlineCode>echo.proto</CH.InlineCode> file and define our message types:

```rust ~/echo/echo.proto
syntax = "proto3";

option go_package = "/echo";

message Request {
  string Message = 1;
}

message Response{
  string Message = 1;
}
```

You can see that we've defined two message types, one for the <CH.InlineCode>Request</CH.InlineCode> and one for the <CH.InlineCode>Response</CH.InlineCode>.

Next, we will define a new **Echo Service** in our <CH.InlineCode>proto3</CH.InlineCode> file. This tells the compiler that we want to generate a server and client for this service.

```rust ~/echo/echo.proto
syntax = "proto3";

option go_package = "/echo";

// focus(1:3)
service EchoService {
  rpc Echo(Request) returns (Response);
}

message Request {
  string Message = 1;
}

message Response{
  string Message = 1;
}
```

And with that you should be ready. Next we'll start the <CH.InlineCode>protoc</CH.InlineCode> compiler to generate
our FRPC server and client.

# Generate the Server and Client

Let's run the following command to generate the server and client code:

```nix
$ protoc --frisbee_out=. echo.proto
```

This command tells the <CH.InlineCode>protoc</CH.InlineCode> compiler to generate the server and client code for us and
by specifying the <CH.InlineCode>--frisbee_out</CH.InlineCode> flag, we're implicitly specifying that we want to use the

<CH.InlineCode>protoc-gen-frisbee</CH.InlineCode> plugin.

If we wanted to be more explicit, we could have run the following command:

```nix
$ protoc --plugin=protoc-gen-frisbee=$GOBIN/protoc-gen-frisbee --frisbee_out=. echo.proto
```

These commands should have generated a new folder at <CH.InlineCode>~/echo/echo</CH.InlineCode>, which
contains an <CH.InlineCode>echo.frisbee.go</CH.InlineCode> file containing the server and client code. Within
that file, you'll find the following interface:

```go echo.frisbee.go
...

type EchoService interface {
	Echo(context.Context, *Request) (*Response, error)
}

...
```

All we have left to do is implement the <CH.InlineCode>EchoService</CH.InlineCode> interface with our server-side logic,
and pass that into the server. The generated library will then be able to handle everything else for us.

# Setting up the Server

To set up our server, we simply need to implement the <CH.InlineCode>EchoService</CH.InlineCode> interface and then start
the server. We'll start by creating a new <CH.InlineCode>server/main.go</CH.InlineCode> file in our <CH.InlineCode>~/frpc/echo</CH.InlineCode> directory:

```go ~/echo/server/server.go
package main

import (
	"context"
     "frisbee-examples/echo/echo"
)

type svc struct{}

func (s *svc) Echo(_ context.Context, req *echo.Request) (*echo.Response, error) {
	res := new(echo.Response)
	res.Message = req.Message
	return res, nil
}
```

As you can see we've created a new struct called <CH.InlineCode>svc</CH.InlineCode> and implemented the <CH.InlineCode>EchoService</CH.InlineCode> interface by
creating a new function called <CH.InlineCode>Echo</CH.InlineCode> which takes a <CH.InlineCode>context.Context</CH.InlineCode> and an <CH.InlineCode>*echo.Request</CH.InlineCode> object.
We aren't really using the context in this example so we just ignore that and instead return an <CH.InlineCode>*echo.Response</CH.InlineCode> object with the
same message as the request.

Now we can implement the server itself:

```go ~/echo/server/server.go
package main

import (
	"context"
	"github.com/loopholelabs/frisbee"
	"github.com/rs/zerolog"
     "frisbee-examples/echo/echo"
	"log"
	"os"
	"runtime"
	"time"
)

type svc struct{}

func (s *svc) Echo(_ context.Context, req *echo.Request) (*echo.Response, error) {
	res := new(echo.Response)
	res.Message = req.Message
	return res, nil
}

// focus(1:11)
func main() {
	frpcServer, err := echo.NewServer(new(svc), nil, nil)
	if err != nil {
		panic(err)
	}

	err = frisbeeServer.Start(":8080")
    if err != nil {
        panic(err)
    }
}

```